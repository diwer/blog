<p>##第五章 初始化与清理</p>
<p>##5.1用构造器确保初始化
一般提供带参数的构造函数的同时，应该提供不带参的。除非你构造这个对象时要求必须有这个值</p>
<p>##5.2方法重载</p>
<ol>
<li>方法重载会导致二义性，所以必须要求你的重载方法有唯一的形参列表</li>
<li>基本类型有提升类型的现象，所以要考虑到影响</li>
<li>在传入参数时，还要考虑 转换类型丢失的精度问题</li>
<li>还可以用返回值类型来避免重载方法的二义性</li>
</ol>
<p>##5.4<code>this</code>关键字</p>
<ol>
<li>在对象调用方法是，有一个暗操作，就是把对象本身作为参数传递，this就是方法体里接收传递过来的对象本身</li>
<li>return this 可以做到链式编程</li>
<li>构造器调用构造器是被允许的，就像简单的函数调用一样，<strong><em>但是只允许调用一次</em></strong></li>
<li>对于1描述的暗操作 <code>static</code>方法是没有的，所以说<code>static</code>方法是针对类而非某一个对象</li>
</ol>
<p>##5.5清理：终结处理和垃圾回收</p>
<ol>
<li>java的垃圾回收只负责由你用new创建的对象</li>
<li>java的垃圾回收不等于析构</li>
<li>垃圾回回收，但不能保证在什么时间里回收</li>
<li>finalize() 函数只是在垃圾回收时被调用，而非调用时垃圾回收</li>
<li>finalize() 函数的使用多数场景为java中调用了非java代码</li>
<li>垃圾回收的几种模式（建议阅读原文）<ol>
<li><strong><em>停止-复制</em></strong><br>先暂停程序运行，然后将活着的对象复制到另一个堆，完成内存的紧凑调整，和老旧引用的更新，然后删除老堆里的对象  <ol>
<li>由于需要两个堆来回折腾，内存需要一倍空间（有些实现，在同一个堆得两块大内存完成）</li>
<li>程序进入稳定状态后，产生的垃圾对象变少，复制式回收会进行不必要的复制。</li>
</ol>
</li>
<li><strong><em>标记-清理</em></strong><br> 从堆栈和静态存储区扫描所有引用标记活着的对象，在完成所有的标记后清理未标记的垃圾对象<ol>
<li>清理后的内存是不连续的，需要整理内存</li>
<li>速度会很慢，使用情况在程序稳定期</li>
</ol>
</li>
<li><strong><em>分代清理</em></strong><ol>
<li>分为三代 年轻代，年老代，永久代 </li>
<li>初始都为年轻代，在清理后存活的升代，调整内存位置</li>
</ol>
</li>
<li>jit即时编译技术<br> 部分代码编译为机器码，而非字节码提高即时编译速度问题，度量代码使用率，有些代码可能从不被jit编译</li>
<li>java hotspot技术<br>代码每次执行都会进行优化，执行次数越多，速度越快</li>
</ol>
</li>
</ol>
<p>##5.6成员初始化      </p>
<ol>
<li>局部变量未初始化 编译错误</li>
<li>成员变量初始化 未指定则有默认值，保证初始化过，但不保证合法有效  </li>
</ol>
<p>##5.7构造器初始化</p>
<ol>
<li>初始化顺序有变量定义书序决定</li>
<li>静态对象的初始化 只在第一次被使用时初始化</li>
<li>显示的静态初始化块 也是在第一次被使用时初始化</li>
<li><strong><em>该类的第一个对象初始化即类的静态成员第一次使用</em></strong></li>
<li>非静态实例化 用法与静态实例化都是大括号但少了关键字static</li>
<li>费静态实例化发生在构造函数之前</li>
<li>构造顺序总结<br> <strong><em>静态实例化&gt;非静态实例化&gt;构造函数</em></strong></li>
</ol>
<p>##5.8数组初始化</p>
<ol>
<li>基本类型数组 new之后有默认值，不需要初始化</li>
<li>引用类型数组，new之后仅为引用数组，要进行初始化</li>
</ol>
<p>##5.9枚举类型</p>
<ol>
<li>枚举是特殊的类</li>
<li>他是个常量</li>
<li>后面还要学 就不说了-。-！</li>
</ol>
<p>##5.10 总结</p>
<p>垃圾回收多作了解!</p>
