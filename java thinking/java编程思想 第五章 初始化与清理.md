##第五章 初始化与清理

##5.1用构造器确保初始化
一般提供带参数的构造函数的同时，应该提供不带参的。除非你构造这个对象时要求必须有这个值
##5.2方法重载
1. 方法重载会导致二义性，所以必须要求你的重载方法有唯一的形参列表
2. 基本类型有提升类型的现象，所以要考虑到影响
3. 在传入参数时，还要考虑 转换类型丢失的精度问题
4. 还可以用返回值类型来避免重载方法的二义性

##5.4``this``关键字
1. 在对象调用方法是，有一个暗操作，就是把对象本身作为参数传递，this就是方法体里接收传递过来的对象本身
2. return this 可以做到链式编程
3. 构造器调用构造器是被允许的，就像简单的函数调用一样，***但是只允许调用一次***
4. 对于1描述的暗操作 ``static``方法是没有的，所以说``static``方法是针对类而非某一个对象

##5.5清理：终结处理和垃圾回收
1. java的垃圾回收只负责由你用new创建的对象
2. java的垃圾回收不等于析构
3. 垃圾回回收，但不能保证在什么时间里回收
4. finalize() 函数只是在垃圾回收时被调用，而非调用时垃圾回收
5. finalize() 函数的使用多数场景为java中调用了非java代码
6. 垃圾回收的几种模式（建议阅读原文）
    1. ***停止-复制***  
       先暂停程序运行，然后将活着的对象复制到另一个堆，完成内存的紧凑调整，和老旧引用的更新，然后删除老堆里的对象  
       1. 由于需要两个堆来回折腾，内存需要一倍空间（有些实现，在同一个堆得两块大内存完成）
       2. 程序进入稳定状态后，产生的垃圾对象变少，复制式回收会进行不必要的复制。
    2. ***标记-清理***  
        从堆栈和静态存储区扫描所有引用标记活着的对象，在完成所有的标记后清理未标记的垃圾对象
       1. 清理后的内存是不连续的，需要整理内存
       2. 速度会很慢，使用情况在程序稳定期
    3. ***分代清理***
       1. 分为三代 年轻代，年老代，永久代 
       2. 初始都为年轻代，在清理后存活的升代，调整内存位置
    4. jit即时编译技术  
        部分代码编译为机器码，而非字节码提高即时编译速度问题，度量代码使用率，有些代码可能从不被jit编译
    5. java hotspot技术  
       代码每次执行都会进行优化，执行次数越多，速度越快
         
##5.6成员初始化      
1. 局部变量未初始化 编译错误
2. 成员变量初始化 未指定则有默认值，保证初始化过，但不保证合法有效  

##5.7构造器初始化
1. 初始化顺序有变量定义书序决定
2. 静态对象的初始化 只在第一次被使用时初始化
3. 显示的静态初始化块 也是在第一次被使用时初始化
4. ***该类的第一个对象初始化即类的静态成员第一次使用***
5. 非静态实例化 用法与静态实例化都是大括号但少了关键字static
6. 费静态实例化发生在构造函数之前
7. 构造顺序总结  
    ***静态实例化>非静态实例化>构造函数***

##5.8数组初始化
1. 基本类型数组 new之后有默认值，不需要初始化
2. 引用类型数组，new之后仅为引用数组，要进行初始化

##5.9枚举类型
1. 枚举是特殊的类
2. 他是个常量
3. 后面还要学 就不说了-。-！

##5.10 总结

垃圾回收多作了解!