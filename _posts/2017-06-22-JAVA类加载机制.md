---
title: JAVA类加载机制 
tags: []
date: 2017-06-22
grammar_cjkRuby: true
---
日期: 2017-06-22 21:18:22

# JAVA类加载机制 
类从被加载到虚拟机内存中开始，到卸载出内存为止，生命周期：加载，链接，初始化，使用，鞋子啊
## 类初始化
1. 用到new，getstatic,putstatic,invokestatic 这4条字节码时候，如果类没有进行初始化，则需要先触发其初始化
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先出发其初始化
3. 当初始化一个雷的时候，发现他的父类还没有初始化，则先触发父类的初始化
4. 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个类
5.当使用JDK1.7的动态语言支持时候，如果一个java.lang.invoke.MethodHandle实例最后解析结果为ref_getstatic
ref_putstatic,ref_invokestatic的方法句柄，并且这个方法句柄对应的类没有进行初始化 ，则需要先触发初始化
## 加载器分类
java虚拟机有两种不同的类加载器：一是启动类加载器，这个类加载器是C++实现的，是虚拟机自身的一部分，另一个种是所有其他的类加载器，这些类都是有java语言实现的独立于虚拟机外部并且继承抽象类java.lang.ClassLoader.
### java虚拟机需要完成以下3件事
a. 通过一个类的全限定名来获取顶一个此类的二进制字节流。
b. 将定义类的二进制字节流所代表的静态存储结构转换为方法区的运行时数据结构。
c. 在java堆中生成一个代表该类的java.lang.Class 对象，作为方法区数据的访问入口
从java开发人员的角度来看分为3种类加载器
## 类加载器
1. 启动类加载器
这个类加载器负责将存放在JAVA_HOME/lib下的，或者被-Xbootclasspath参数锁指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中，启动类加载器无法被程序应用
2. 扩展类加载器
这个加载器负加载JAVA_HOME/lib/ext 目录中，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展加载器
3. 应用程序类加载器
这个加载器是classloader中getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它为系统类加载器。它负责加载用户类路径上指定的类库，可直接使用这个加载器，如果应用程序没有定义自己的类加载器，一般情况下这个就是程序中默认的类加载器
## 类加载的双亲委派模型
双亲委派模型要求除了顶层的启动类加载器外，其他的累加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实习，而是都是用组合关系来复用父加载器的代码
### 工作过程
如果一个类加载器收到了类加载的请求，它首先不会自己取尝试加载这个类，而是把这个请求委派给父类加载去完成，每一个层次的类加载器都是如此，因此所有的加载请求都应该传递到顶层的启动类加载器中
只有当父类加载器反馈自己无法完成这个请求，子加载器才会尝试自己取加载
java类随着它的类加载器一起具备了一种带有优先级的层次挂你，例如类Object，他放在rt.jar，无论哪一个类加载器要加载这个类，最终都是委派给启动加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类

判断两个雷是否相同是通过classloader.class 这种方式进行的，所以哪怕是同一个class文件如果被两个classloader加载，那么他们也是不同的类
## 实现自己的加载
只需要继承ClassLoader，并覆盖findClass方法
在调用loadClass方法时，会先根据委派模型在父加载器中加载，如果加载失败，会盗用自己的findClass方法来完成加载
## 类加载器如何识别
通过findLoaderClass方法时，会先根据委派模型在父加载器中架子啊，如果加载失败，则会调用自己的findClass方法来完成加载

----

wanheming1991@gmail.com