---
title: Java垃圾回收机制
tags: []
date: 2017-06-22
grammar_cjkRuby: true
---
日期: 2017-06-22 14:20:21

# JAVA垃圾回收机制
## 如何判断一个对象死去
1. 引用计数法：
	只要有一个地方引用它，计数器就加1，引用失效计数器减去1，优点实现简单，效率高，缺点是无法解决循环引用问题
2. 可达性分析：
	以`GC Roots`的对象作为起始点，从这些节点向下搜索，走过的路径成为引用链，当一个对象到GC Roots没有任何引用链，则对象不可达，可回收。
### 可作为GC Roots的对象包括哪些
1. 虚拟机栈中引用的对象
2. 方法去中类静态属性引用的对象
3. 方法去中常量引用的对象
4. 本地方法栈中 `JNI`(java native interface)引用的对象
## 引用的分类
* 强引用
	通过new出来的引用，只要强引用还存在，就不能回收
* 软引用
	通过softreference类实现，用来描述一些有用但非必须的对象。在系统将要发生内存溢出异常之前，会把这些对象回收，如果这次回收内存还不够的话，才能跑出溢出异常
* 弱引用
	非必须对象，通过WeakReferenc类实现，被弱引用引用的对象，只要已发生GC就会把它干掉
* 虚引用
	通过PhantomReference类实现，无法通过虚引用过得对象的实力，唯一的作用就是这个对象呗Gc会受到一个系统通知
## 回收方法区(永久代)
来存储class类，常量，方法描述
* 回收废弃常量，就是没有热河实例叫这个常量
* 回收无用类，
	* 所有实例都被回收 
	* 加载该类的ClassLoader也被回收
	* 该类对饮的java.lang.Class对象没有引用关系
## 垃圾回收算法
垃圾回收算法主要有四种：`标记-清除（Mark-Sweep）``复制算法（Copying）``标记-整理（Mark-Compact）``分带收集算法`
### 标记-清除算法
* 首先标记处所有需要回收的对象，在标记完成后统一回收被标记的对象
* 缺点
	* 效率 标记和清除两个过程效率都不高
	* 空间 标记清除会造成大量的内存碎片
### 复制算法
它将内存容量规划分为大小相等两块，每次只使用其中的一块，当一块内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过得内存空间一次清理掉。
1. 优点 速度快，实现简单
2. 缺点 浪费空间
	但是可以进行优化，用来复制的内存块并不需要大小一致，在商业虚拟机 采用比例 8：1：1 浪费空间10%
### 标记-整理算法
根据老年代的特点，有人提出来标记整理算法，也就是先标记处所有需要回收的对象，但后续不走不是对可回收对象进行清理，可是让所有存货的对象都向一段移动，然后直接清理掉端边界意外的内存。适用于老年代
### 分代收集算法
分代收集算法，根据对象的存货周期的不同将内存划分为几块，一般java堆分为心神带和老年代，这样就可以根据各个年代的特点使用不同的收集算法提高效率
新生代中每次垃圾收集时都会有大批对象被回收，只有少量存货，所以采用复制算法，只需要少量内存空间用于复制，
老年代中对象存活率高，没有额外担保，所以必须适用于标记-清除 或标记整理算法
## 垃圾收集器
垃圾收集算法是内存回收的理论基础，而垃圾收集器就是内存回收的具体实现
1. `Seria`l Vs `Serial Old`
	Serial Old该收集器是最老的收集器，是单线程，并且进行垃圾收集时，所有用户线程必须暂停，即线程停顿，针对老年代的收集器，使用Mark-Compact算法，
	Serial 针对新生代收集器采用Copying算法
2. ParNew
	该收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集，除了Serial外，只有ParNew能跟CMS配合工作，因此采用Cms作为老年代收集器的，新生代收集器只能采用ParNew或Serial。
3 Parallel Scavenge
	改收集器是新生代的多线程收集器，在回收期间不需要暂停其他用户线程，采用Copying算法，该收集器与前两个收集器有所不同，主要为了达到一个可控的吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗的时间占比
4. Parallel Old
 	是Parallel Scavenge的老年代收集版本，使用多线程和Mark-Cpmpact算法
5. CMS
	Current Mark Sweep 该收集器是一种以获取最短停顿时间为目标的收集器，他是一种并发收集器，采用的是Mark-Seep算法
6. G1
	G1 比较新潮，能最大的利用CPU,多核华景，是并行并发收集器，并且他能建立可预测的停顿时间模型
## Minor GC 与Full GC
### Minor Gc
新生代垃圾回收的动作，java对象大多具朝生熄灭的特性，所以Minor GC 非常频繁，一般回收速度也比较快，当Eden区满了就会发生MinorGc
### Full GC
老年代的GC，会执行Major GC 和MinorGC 可以简单理解为调用minorGC 后紧接着调用Major GC

## 对象分配原则
1. 对象优先分配在Eden区，如果Eden区没有足够的空间则gc
2. 大对象直接进入老年代（大量使用连续内存空间的对象），这样做的目的是避免在Eden和两个临时区发生大量的内存拷贝
3. 长期存活的对象进入老年代，虚拟机为每个对象定义了一个年龄计数器，用minorGC次数迭代，通过阀值对象进入老年区
4. 动态判断对象年龄，如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一般，年龄大于或等于改年龄的对象可以直接进入老年代
5. 空间分配担保，每次进行MinroGc，jvm会计算Survivor区移到老年区的对象平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查

----

wanheming1991@gmail.com