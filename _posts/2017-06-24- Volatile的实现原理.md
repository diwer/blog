---
title: Volatile的实现原理
tags: [并发,volatile]
date: 2017-06-24
grammar_cjkRuby: true
---
日期: 2017-06-24 12:17:19

# Volatile的实现原理
Volatile 是轻量级别的 synchronized，在多处理器开发中保证了共享变量的可见性，在一个线程修改一个变量时，另外一个线程能读到这个修改的值。
* 共享变量
在多个线程之间能够被共享的变量，包括所有实例变量，静态变量和数组元素。他们都被存放在堆内存中volatile只作用于共享变量
* 内存屏障 
	是一组处理器指令，用于实现堆内存操作的顺序限制
* 缓冲行
	缓存中可以分配的最小存储单位，处理器填写缓存线时会加载整个缓存线，需要多个主内存读周期
* 原子操作
	不可中断的一个或一些列操作
* 缓存行填充
	当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存
* 缓存命中
	如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存里
* 写命中
	当处理器将操作数歇会到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写会缓存，而不是写会到内存，这个操作是写命中
* 写缺失
	一个有效的缓存行被写入到不存在的内存区域
## volatile的官方定义
java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排它锁单独获得这个变量，java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值一致的
volatile 不会引起线程上下文的切换和调度。比synchionized的使用和执行成本会更低
## Volatile的实现原理
那么volatile 是如何来保证可见性的呢？在x86处理器下通过工具获取jit编译器生成的汇编指令来看对volatile进行写操作的cpu做什么事情
有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，lock前缀的指令在多核处理器下会引发两件事。
* 将当前处理器缓存行的数据会写回系统内存。
* 这个写回内存的操作会引起在其他cpu里缓存了该内存地址的数据无效
处理器为了提高处理速度，不直接和内存进行通讯，而是先系统内存的数据读到内部缓存h后再进行操作，但操作完之后不知道何时会写内存，如果对声明了Volatile变量进行写操作，JVM就会想处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据歇会到系统内存。但是就算写回内存，如果其他处理的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，当处理器发现自己的缓存行对应的内存地址被修改，就会当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作时候，会强制重新从系统内存里把数据读到处理器缓存里。
**lock前缀指令会引起处理器缓存会写到内存**。lock前缀指令导致在执行指令期间，声言处理器的lock信号，再多处理器环境中，lock信号确保在声言该信号期间，处理器可以独占任何共享内存。但是在最近的处理器里，lock信号一般不锁总线，而是锁缓存，总线开销比较大。锁定内存区域的缓存并回写内存，并使用缓存一致性机制来确保修改原子性，此操作被称为缓存锁定。**缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据**
**一个处理器的缓存会写到内存会导致其他处理器的缓存无效**
## volatile的优化使用
共享变量被频繁操作的需要补齐处理器的缓存行

## volatile的特性

理解volatile特性的一个好方法是对volatile变量的单个读写,看成是使用锁对这个单个读写操作做了同步
锁的happens-before规则保证释放所和获取锁的两个线程之间的内存可见性,这意味着对volatile变量的读,总是能看到对这个volatile变量最后的写入
锁的语义决定了另截取代码的执行具有原子性,这意味着,即使是64位的long型和double型变量,只要它是volatile变量,对该变量的读写就具有原子性,如果十多个volatile操作或类似于volatile++这种复合操作这些操作整体上不具有原子性

## volatile写-读建立的happens-before关系

volatile变量自身的特性,对程序猿来说,volatile对线程的内存可见性的影响比volatile自身的特性更为重要,.
volatile的写-读可以实现线程之间的通信
从内存语义的角度来说,volatile的xie-读与锁的释放-获取有相同的内存效果;volatile写-和锁的释放有相同的内存语义,volatile读与锁和获取有相同的内存语义
### volatile写-读的内存语义
1. volatile的写的内存语义
当写一个volatile变量时,jmm会把该线程对应的本地内存的共享变量值刷新到主内存
2. volaitile读的内存语义
当读一个volatile变量时,jmm会把线程对应的本地内存置为无效.线程接下来将从主内存中读取共享变量
## volatile内存语义的实现
![volatile重排序规则表][1]
* 第二个操作为v写时,不管第一个操作是什么都不能重排序.这个规则保证v变量写之前的操作不会被重排序到volatile写之后
* 当第一个操作是volatile读,不管第二个操作是什么,都不能重排序,这个规则确保volatile度之后的操作不会被编译器重排序到volatile读之前
* 当第一个操作是volatile写,第二个操作是volatile读是,不能重排序

> 阻止重排序 使用内存屏障实现
插入内存屏障策略:
* 每个volatile写操作的前面插入一个sotrestore屏障
* 每个volatile写操作的后面插入-个StoreLoad屏障
* 每个volatile读操作的后面插入一个LoadLoad屏障
* 每个volatile读操作的后面插入一个LoadStore屏障
> 由于处理器平台有各自实现方式,所以采用保守内存屏障插入策略
![指令序列示意图][2]
> volatile后面的storeload屏障.ci'ping'zhang

----

wanheming1991@gmail.com


  [1]: http://oq6m1y13p.bkt.clouddn.com/1500623450934.jpg
  [2]: http://oq6m1y13p.bkt.clouddn.com/1500623837747.jpg