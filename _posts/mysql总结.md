---
title: mysql总结
tags: [mysql]
date: 2017-06-19 10:30:34
grammar_cjkRuby: true
---
日期: 2017-06-19 10:30:34

# mysql 总结
## 为何使用innodb引擎
1. 支持事物，行级锁提高并发性，buffer pool中缓存数据和索引，mvcc，热备份，安全
2. UFT8MB4,4字节UTF8编码，能存更多字符集（UTF8为3字节）
## 如何存储IPV4/IPV6
UNSINGED INT 存储ip地址，通过换出把ip地址转为int值，进行查询
## int(1) 1表示什么
显示字符宽度，非存储长度，一般和zerofill搭配使用，用于设置数据宽度补全（位数不够左补零）
## 分库分表策略
单标行数超过500万或者单标容量超过2G，比较适合分库分表。
把一个很大的库，数据分到几个库，每个库的结构相同，可以在不同实例上，降低单库数据量从而提升查询性能。
* 使用hash散列，表明后缀使用十进制，数字从0开始
* 按日期时间分割表须符合yyyyMMDDHH格式，按日期散列，或按月散表
* 分库分表 表不易过多。可用多库少表的思想

## 禁止使用分区表
数据还在一个表中，但物理存储根据一定股则存放在不同文件中（mysql底层实现）
* 分区键设计不灵活，只能通过主键或唯一列进行分区，不用分区键做查询，很容易出现全表锁
* 分区表连表查询性能很差
* null值无法通过分区列进行过滤。 不能能垂直分区
* 分区个数有限，分区增多性能下降
* 分区表在表变大后，ddl sharding 单表恢复 较困难

## innodb事务隔离级别和锁关系
1. 共享锁（S）
2. 拍他所 (X)
3. 意向共享锁 (IS)
4. 意向排它锁 (IX)
意向锁是申请s或x锁前申请的锁

### innodb锁注意事项
* innodb的行锁是加在索引上的
* innoDb的S锁之间共享，S锁和X锁互斥，X锁之间互斥
* innoDb对于索引列的修改会锁定更多的行
* 同意资源的锁升级会导致死锁
> innodb行级锁并不是直接锁定记录，而是通过索引项加锁实现，这种行锁只有通过索引条件检索数据，才会使用，不用则使用表级锁
这个特性要注意，否则会有大量锁冲突，影响并发性能。
> select * from test where name ='张三' for update;
> select * from test where name ='李四' for update;
由于name列没有索引，事物1 会锁表，锁住所有行，然后进行过滤，将不符合条件的及了解所，当两个事物并发执行时，会导致后一个锁等待
### innodb锁类型
1. recode lock 对索引项加锁，即行锁
2. Gap lock 间隙锁，锁定一个范围，但不包括记录本身
3. Next-key Lock  1+2 锁定一个范围 病锁定记录本身
4. auto-inc lock： 自増锁
* Gap lock
	`mysql`索引是B+树的数据结构
例如有两条数据，属性咧teacher_id 分别为5，30，则缩影结构为
（-∞，5],(5,30],(30,+∞),
update * * where teacher_id=30，会用到行锁30，同时（5，30],(30,+∞)都加了间隙锁，其他事物就不能在这两个区间插入数据，update * * where teacher_id=20,会在区间(5,30] 加间隙锁，其他区间不受影响.
update * * where teacher_name='test'  全表加入gap锁，其他事无法插入
行锁防止别的食物修改或删除，Gap锁防止别的事务新增

#### 案例分析
``` sql
	A:T1 start Transaction
	B:T2 start Transaction
	C:T1 delete from `oder` where customer_id=3
	D:T2 delete from `order` where customer_id =5
	E:T1 insert into `order` (customer_id) values(3)
	F:T2 insert into `order` (customer_id) values(5)
```
* 执行 C语句完毕 T1持有gap（2，6）X锁
* 执行D语句T2申请Gap（2，6）X锁 根据“precise mode”兼容矩阵 申请该授权 T2持有 Gap（2，6）
* 执行E语句 T1申请了 x锁 根据矩阵 由于T2持有Gap（2，6）的X锁，该申请被拒绝
* 执行F语句 T2申请insert （2，6）的X锁 同理被T1Gap（2，6）X锁拒绝 造成 等待 最后变成T1 T2的死锁
![锁的兼容性矩阵][1]
### 避免死锁
* 每次操作数据不宜过多，尽量减少锁定时间
* 更细或删除数据时，避免删除没有的数据，根据主键操作，避免交叉锁定
* Sql中涉及的表尽量少，不要多表联合操作，减少占用资源
* 业务端尽量已主键或索引按照一定属性进行操作，避免交叉等待
* 在表上设计合理索引，并且有自增主键列，尽量减少对索引列进行更新
* 尽量减少表上的索引，避免锁定资源过多
### 隔离级别
>脏读：B事务读到A事务中未提交的数据
>可不重复度：A事务中两次读取同一数据，由于B事务旗舰提交了事务，导致两次结果不一致
>幻读： 事务A修改表中部分数据，事务B插入数据并提交，事务A发现还有没修改的数据
* 读未提交 read uncommited：所有事务都可以读到其他事务未提交的数据，也成脏读
* 读已提交 read commited: 事务只能看到已提交的改动。无脏读问题，但有不可重复读和幻读问题；
* 可重复读 repeatable read：事务读数据数据时这些数据加锁，达到同一个事务多次读取内容结果相同。
	但有幻读问题：用户读取一个范围的数据行时，另一个事务在该范围内插入新行,当用户再次读取该范围的数据行时，发下有新的幻影行，因为此隔离级阻止此范围数据的写事务（update，delete行锁），但不包括insert（新行无法加锁）
* 串行读：事务排队，只能进行排队开启事务

|隔离级别				|脏读|不可重复度|幻读|
|---------------------|-----|-------------|-----|
|Read uncommited|存在	  |存在	     |存在|
|read commited     |不存在|存在        |存在|
|repeatable read    |不存在|不存在    |存在|
|serializable           |不存在|不存在    |不存在|

不可重复度和幻读的区别
不可重复读重点在于update和delete，而幻读的重点在于insert
### mysql的读写问题
#### MVCC
MVCC(多版本并发控制) 实现非阻塞式读，减少锁的使用从而提高读性能(乐观锁)
MVCC在mysql innodb的实现
在 RC隔离级别，查询的最新版本的数据
在RR隔离级别，查询小于等于当前事务版本的数据，从而不必对读操作加锁，提高并发性，通过MVCC解决RR格力几下出现的幻读问题
innoDb通过在每行记录中增加两个隐藏列实现，一个保存此行数据何时创建，一个保存此行的何时过期，实际操作中，存储的不是时间，而是事务的版本号，没开启一个事务版本号+1
在RR隔离级
* select时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号的数据（这个主要为了确定当前十五开始之前，行没有被删除）,符合上述两点的数据返回
* insert时，保存当前事务版本号到行创建版本号
* delete时，保存当前事务版本号到行的删除本号
* update时，插入一行新纪录，保存当前事务版本号到此行创建版本号，同时保存当前事务版本号到原行的删除版本号
innodb RR隔离级别，A读数据->A更新数据->B插入数据->A读数据,发现没有读到B插入的数据，通过MVCC实现了RR隔离级下的幻问题
#### 快照读和当前读
在MVCC中，为了减少锁等待时间，提高并发能力，将读拆分为：
* 快照读：select * from table ..(不需加锁)
* 当前读：特殊的读操作，用于插入更新删除操作，处理的当前数据，
	* select * from table where ? lock in share mode
	* select * from table where ? for update
	* insert/update/delete 为了解决当前读中的幻读问题，Mysql

事务中使用Next-key锁（gap Lock+ record lock)
mysql innoDb中：A读数据->A修改数据->B插入数据并提交->A读数据
RC隔离级下，有当前读的幻读问题。
RR隔离级下，B无法插入处于等待，A提交后B才能提交执行，避免了幻读。

**mysql如何解决RR隔离级下再写数据时幻读问题**
通过 next-key锁，行锁防止别的事务修改或删除，Gap锁防止别的食物新增
----

wanheming1991@gmail.com


  [1]: http://oq6m1y13p.bkt.clouddn.com/1497945329364.jpg