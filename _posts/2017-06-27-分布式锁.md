---
title: 分布式锁
tags: [redis,分布式]
date: 2017-06-27
grammar_cjkRuby: true
---
日期: 2017-06-27 21:53:00

# 分布式锁
## 分布式锁常见问题
* 尺有所得进程因为操作时间过长而导致锁被自动释放,但进程本身并不知道这一点, 甚至可能会错误的释放掉别的线程中的锁
* 一个尺有所并打算执行长时间的操作的进程已经崩溃,但其他想要获取锁的进程不知道那个进程持有锁,一万五发检测出尺有所得进程已经奔溃,之恩给你白白的浪费时间等待锁被释放
* 在一个进程持有的锁过期之后,其他多个进程同时获取锁,并且都获得了锁
* 第一种情况和第三种情况同事出现,导致有多个进程获得了锁,而每个进程都以为自己是唯一一个活的锁的进程

## redis版本
>redis性能 普通硬件每秒100k个操作,高端硬件可以225k操作.上面描述的问题出现的概率只有万分之一,但在高负载情况下还是可能会出现
>在实际测试中使用带有超时性质的redis锁实现,使用5个哭护端来获取和释放同一个锁,至少有一半的锁实现在10秒内会出现多个客户端都获取锁的问题

* setnx 命令 
	setnx命令填上就是和用来实现锁的获取功能,这个命令只会在键不存在的情况下为键设置值,而锁要做的就是讲一个随机生成的uuid设置为键的值,并使用这个值防止锁被其他进程取得
## zk版本
每个客户端对某个功能加锁时,在zk上的与该功能对应的指定节点的目录下,生成一个唯一的瞬时有序节点,判断时候否获取锁的方式很简单,只需要判断有序节点中序号最小的一个,当释放锁的时候,只需要将这个瞬时节点删除,同事可以避免获取锁的线程的锁无法释放,导致死锁
1. 优点 锁安全性高,zk可持久化
2. 缺点,性能开销比较高,因为其需要动态产生,(zk的创建节点需要leader发起投票,follower投票最后产生)
3. 实现,可使用第三方库curator ,方便的实现zk分布式锁核心代码
4.;

----

wanheming1991@gmail.com